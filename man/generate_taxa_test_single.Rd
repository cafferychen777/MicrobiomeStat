% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generate_taxa_test_single.R
\name{generate_taxa_test_single}
\alias{generate_taxa_test_single}
\title{Conduct Differential Abundance Testing Using LinDA Method in MicrobiomeStat Package}
\usage{
generate_taxa_test_single(
  data.obj,
  time.var = NULL,
  t.level = NULL,
  group.var,
  adj.vars = NULL,
  prev.filter = 0,
  abund.filter = 0,
  feature.level,
  feature.dat.type = c("count", "proportion", "other"),
  ...
)
}
\arguments{
\item{data.obj}{A list object in a format specific to MicrobiomeStat, which can include components such as feature.tab (matrix), feature.ann (matrix), meta.dat (data.frame), tree, and feature.agg.list (list). The data.obj can be converted from other formats using several functions from the MicrobiomeStat package, including: 'mStat_convert_DGEList_to_data_obj', 'mStat_convert_DESeqDataSet_to_data_obj', 'mStat_convert_phyloseq_to_data_obj', 'mStat_convert_SummarizedExperiment_to_data_obj', 'mStat_import_qiime2_as_data_obj', 'mStat_import_mothur_as_data_obj', 'mStat_import_dada2_as_data_obj', and 'mStat_import_biom_as_data_obj'. Alternatively, users can construct their own data.obj. Note that not all components of data.obj may be required for all functions in the MicrobiomeStat package.}

\item{time.var}{Character string specifying the column name in metadata containing time variable.
Used to subset data to a single timepoint if provided. Default NULL does not subset.}

\item{t.level}{Character string specifying the time level/value to subset data to,
if a time variable is provided. Default NULL does not subset data.}

\item{group.var}{Character string specifying the column name in metadata containing the predictor
variable for differential abundance testing. Can be either:
\itemize{
  \item Categorical (factor or character): Performs pairwise comparisons against
        the reference level (first level). Each non-reference level gets a separate
        comparison (e.g., "Treatment vs Control (Reference)").
  \item Continuous (numeric or integer): Tests for linear association between the
        variable and abundance. Output shows a single coefficient representing the
        slope (e.g., effect per unit increase).
}}

\item{adj.vars}{Character vector specifying column names in metadata containing covariates.
These will be used for adjustment in differential abundance testing.}

\item{prev.filter}{Numeric value specifying the minimum prevalence threshold for filtering
taxa before analysis. Taxa with prevalence below this value will be removed.
Prevalence is calculated as the proportion of samples where the taxon is present.}

\item{abund.filter}{Numeric value specifying the minimum abundance threshold for filtering
taxa before analysis. Taxa with mean abundance below this value will be removed.
Abundance refers to counts or proportions depending on \code{feature.dat.type}.}

\item{feature.level}{The column name in the feature annotation matrix (feature.ann) of data.obj
to use for summarization and plotting. This can be the taxonomic level like "Phylum", or any other
annotation columns like "Genus" or "OTU_ID". Should be a character vector specifying one or more
column names in feature.ann. Multiple columns can be provided, and data will be plotted separately
for each column. Default is NULL, which defaults to all columns in feature.ann if `features.plot`
is also NULL.}

\item{feature.dat.type}{The type of the feature data, which determines how the data is handled in downstream analyses.
Should be one of:
\itemize{
  \item "count": Raw count data. Uses LinDA method with internal normalization and zero-handling
                 (pseudo-count or imputation).
  \item "proportion": Proportional data (e.g., relative abundances). Uses LinDA method with
                      appropriate zero-handling for compositional data.
  \item "other": Pre-transformed or custom data (e.g., log-transformed, CLR-transformed).
                 Uses standard linear regression models without compositional adjustments.
}
The choice affects preprocessing steps as well as plot axis labels.
Default is "count", which assumes raw OTU table input.}

\item{...}{Additional arguments to be passed to the linda function.}
}
\value{
A nested list structure where:
\itemize{
  \item First level: Named by \code{feature.level} (e.g., "Phylum", "Genus")
  \item Second level: Named by comparisons
        \itemize{
          \item For categorical \code{group.var}: One element per non-reference level,
                named as "Level vs Reference (Reference)" (e.g., "Treatment vs Control (Reference)")
          \item For continuous \code{group.var}: One element named by the variable name (e.g., "age")
        }
  \item Each element is a data.frame with the following columns:
        \itemize{
          \item \code{Variable}: Feature/taxon name
          \item \code{Coefficient}: Log2 fold change (for categorical) or slope coefficient (for continuous)
          \item \code{SE}: Standard error of the coefficient
          \item \code{P.Value}: Raw p-value from the statistical test
          \item \code{Adjusted.P.Value}: FDR-adjusted p-value using Benjamini-Hochberg method
          \item \code{Mean.Abundance}: Mean abundance of the feature across all samples
          \item \code{Prevalence}: Proportion of samples where the feature is present (non-zero)
        }
}
}
\description{
This function applies differential abundance analysis on microbiome data using the LinDA method
(for count/proportion data) or standard linear models (for other data types). It automatically
detects whether the predictor variable is categorical or continuous and applies appropriate
statistical models.
}
\details{
## Statistical Methods

The function automatically selects the appropriate statistical method based on \code{feature.dat.type}:

**For "count" or "proportion" data:**
Uses LinDA (Linear models for Differential Abundance), which:
\itemize{
  \item Handles compositional nature of microbiome data
  \item Performs internal normalization (no pre-normalization needed)
  \item Handles zero-inflation via pseudo-count or imputation
  \item Corrects bias from centered log-ratio transformation
}

**For "other" data:**
Uses standard linear regression models, suitable for:
\itemize{
  \item Pre-transformed data (e.g., log-transformed, CLR-transformed)
  \item Data where compositional adjustments are not needed
}

## Variable Type Handling

The function automatically detects the type of \code{group.var}:

**Categorical variables (factor or character):**
\itemize{
  \item Uses dummy coding with k-1 coefficients for k levels
  \item First level (alphabetically) becomes the reference
  \item Each coefficient compares a level to the reference
  \item Example: For treatment groups A, B, C, output includes "B vs A (Reference)" and "C vs A (Reference)"
}

**Continuous variables (numeric or integer):**
\itemize{
  \item Uses single slope coefficient
  \item Tests for linear association with abundance
  \item Coefficient represents effect per unit increase
  \item Example: For age, coefficient shows abundance change per year
}

## Analysis Workflow

1. **Data Subsetting**: If \code{time.var} and \code{t.level} provided, subsets to that timepoint

2. **Feature Aggregation**: Aggregates features to specified taxonomic level if not "original"

3. **Filtering**: Applies prevalence and abundance filters

4. **Statistical Testing**: Runs LinDA or linear models depending on \code{feature.dat.type}

5. **Results Compilation**: Extracts coefficients, standard errors, p-values, and calculates
   FDR-adjusted p-values using Benjamini-Hochberg method

6. **Metadata Addition**: Adds mean abundance and prevalence for each feature

The function supports covariate adjustment via \code{adj.vars} and allows taxonomic
aggregation at multiple levels for customized analyses.
}
\examples{
\dontrun{
data(peerj32.obj)
test.list <- generate_taxa_test_single(
    data.obj = peerj32.obj,
    time.var = "time",
    t.level = "2",
    group.var = "group",
    adj.vars = "sex",
    feature.dat.type = "count",
    feature.level = c("Phylum","Genus","Family"),
    prev.filter = 0.1,
    abund.filter = 0.0001,
)
plot.list <- generate_taxa_volcano_single(
    data.obj = peerj32.obj,
    group.var = "group",
    test.list = test.list,
    feature.sig.level = 0.1,
    feature.mt.method = "none"
)
}
}
